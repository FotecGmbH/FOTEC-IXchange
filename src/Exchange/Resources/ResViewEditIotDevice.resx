<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="LblChooseOnMap" xml:space="preserve">
    <value>Über Karte auswählen</value>
  </data>
  <data name="LblCodeArea" xml:space="preserve">
    <value>Codearea</value>
  </data>
  <data name="LblConverterType" xml:space="preserve">
    <value>Convertertyp</value>
  </data>
  <data name="LblPositionSource" xml:space="preserve">
    <value>Quelle der Position</value>
  </data>
  <data name="LblSecret" xml:space="preserve">
    <value>Secret</value>
  </data>
  <data name="LblSecretCheckBox" xml:space="preserve">
    <value>Secret eingeben oder generieren</value>
  </data>
  <data name="LblUpstream" xml:space="preserve">
    <value>Upstream</value>
  </data>
  <data name="PageTitle" xml:space="preserve">
    <value>IoT-Gerät</value>
  </data>
  <data name="SubTitle" xml:space="preserve">
    <value>IoT-Gerät erstellen oder bearbeiten</value>
  </data>
  <data name="Txt_BoxIdInfoModal" xml:space="preserve">
    <value>Geben sie die BoxID Ihres Sensors an.</value>
  </data>
  <data name="Txt_ConverterTypeModal" xml:space="preserve">
    <value>Hier können Sie mittels C# Code selber den vom Sensor gesendeten Input konvertieren. Sobald Messwertdefinitionen dem Sensor hinzugefügt werden, werden diese wie in folgendem Beispiel angezeigt. Es folgt ein Beispiel-Code, in welchem Fall der Input als Byte-Array direkt zu einem Text konvertiert wird. Je nach gesendetem Datentyp muss das jeweilige Property für die Konvertierung verwendet werden.</value>
  </data>
  <data name="Txt_ConverterTypeModal_MeasurementBool" xml:space="preserve">
    <value>MeasurementBool für Bit/Boolean - bool</value>
  </data>
  <data name="Txt_ConverterTypeModal_MeasurementImage" xml:space="preserve">
    <value>MeasurementImage für Bild als Datenarray - byte[]</value>
  </data>
  <data name="Txt_ConverterTypeModal_MeasurementNumber" xml:space="preserve">
    <value>MeasurementNumber für Zahl - double</value>
  </data>
  <data name="Txt_ConverterTypeModal_MeasurementRaw" xml:space="preserve">
    <value>MeasurementRaw für ein Byte Array - byte[]</value>
  </data>
  <data name="Txt_ConverterTypeModal_MeasurementText" xml:space="preserve">
    <value>MeasurementText für Text - string</value>
  </data>
  <data name="Txt_ConverterTypeModal_Properties" xml:space="preserve">
    <value>Die zugehörigen Properties für die jeweiligen Werte sind</value>
  </data>
  <data name="Txt_PlattformModal1" xml:space="preserve">
    <value>Für den PC-Sensor starten Sie bitte die Sensor-Applikation auf einem PC. Unterstützt wird hierbei die Übertragungsart "{0}".</value>
  </data>
  <data name="Txt_PlattformModal2" xml:space="preserve">
    <value>Für den Raspberry Pi-Sensor starten Sie bitte die Sensor-Applikation auf einem Raspberry Pi. Unterstützt wird hierbei die Übertragungsart "{0}".</value>
  </data>
  <data name="Txt_PlattformModal3" xml:space="preserve">
    <value>Für den OpenSense-Sensor geben Sie bitte die {0} ein.</value>
  </data>
  <data name="Txt_PlattformModal4" xml:space="preserve">
    <value>Für den ESP32, laden Sie das Firmware Projekt herunter, ändern die TTN Konfigurationswerte, flashen die Firmware auf das Gerät und starten dieses.</value>
  </data>
  <data name="Txt_PlattformModal5" xml:space="preserve">
    <value>Dieser beschreibt einen Sensor, welche ohne de Firmware unseres Firmware Projekts läuft und Daten sendet. Hiebrei kann selbst mittels C# Code eingestellt werden wie die Daten konvertiert werden.</value>
  </data>
  <data name="Txt_SecretModal" xml:space="preserve">
    <value>Der TCP Sensor hat ein Secret um ihn identifizieren zu können. Starten Sie die TCP-Sensor Applikation (downloadbar in Menüpunkt "Inbetriebnahme") und geben Sie dort dieses Secret ein oder geben Sie hier das Secret der TCP-Sensor Applikation ein.</value>
  </data>
  <data name="Txt_UpstreamModal" xml:space="preserve">
    <value>Upstream beschreibt über welche Art der Sensor seine Daten dem Gateway überträgt.</value>
  </data>
</root>